/*
 * This would have easier except I didn't want to touch the source files.
 * The ipython stuff sets the IPython namespace with var which means that 
 * it won't affect globals in browserify. So instead I grab the script
 * contents with the help of brfs and add a return.
 *
 * Note: This file is called when using browserify via the 'browser' section
 * in package.json
 */
var fs = require('fs');
var path = require('path');

var content = "//----------------------------------------------------------------------------\n//  Copyright (C) 2011  The IPython Development Team\n//\n//  Distributed under the terms of the BSD License.  The full license is in\n//  the file COPYING, distributed as part of this software.\n//----------------------------------------------------------------------------\n\nvar IPython = IPython || {};\n\nIPython.version = \"2.0.0-dev\";\n\nIPython.namespace = function (ns_string) {\n    \"use strict\";\n\n    var parts = ns_string.split('.'),\n        parent = IPython,\n        i;\n\n    // String redundant leading global\n    if (parts[0] === \"IPython\") {\n        parts = parts.slice(1);\n    }\n\n    for (i=0; i<parts.length; i+=1) {\n        // Create property if it doesn't exist\n        if (typeof parent[parts[i]] === \"undefined\") {\n            parent[parts[i]] = {};\n        }\n    }\n    return parent;\n};\n\n\n\n//----------------------------------------------------------------------------\n//  Copyright (C) 2008-2012  The IPython Development Team\n//\n//  Distributed under the terms of the BSD License.  The full license is in\n//  the file COPYING, distributed as part of this software.\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Utilities\n//============================================================================\nIPython.namespace('IPython.utils');\n\nIPython.utils = (function (IPython) {\n    \"use strict\";\n    \n    IPython.load_extensions = function () {\n        // load one or more IPython notebook extensions with requirejs\n        \n        var extensions = [];\n        var extension_names = arguments;\n        for (var i = 0; i < extension_names.length; i++) {\n            extensions.push(\"nbextensions/\" + arguments[i]);\n        }\n        \n        require(extensions,\n            function () {\n                for (var i = 0; i < arguments.length; i++) {\n                    var ext = arguments[i];\n                    var ext_name = extension_names[i];\n                    // success callback\n                    console.log(\"Loaded extension: \" + ext_name);\n                    if (ext && ext.load_ipython_extension !== undefined) {\n                        ext.load_ipython_extension();\n                    }\n                }\n            },\n            function (err) {\n                // failure callback\n                console.log(\"Failed to load extension(s):\", err.requireModules, err);\n            }\n        );\n    };\n\n    //============================================================================\n    // Cross-browser RegEx Split\n    //============================================================================\n\n    // This code has been MODIFIED from the code licensed below to not replace the\n    // default browser split.  The license is reproduced here.\n\n    // see http://blog.stevenlevithan.com/archives/cross-browser-split for more info:\n    /*!\n     * Cross-Browser Split 1.1.1\n     * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n     * Available under the MIT License\n     * ECMAScript compliant, uniform cross-browser split method\n     */\n\n    /**\n     * Splits a string into an array of strings using a regex or string\n     * separator. Matches of the separator are not included in the result array.\n     * However, if `separator` is a regex that contains capturing groups,\n     * backreferences are spliced into the result each time `separator` is\n     * matched. Fixes browser bugs compared to the native\n     * `String.prototype.split` and can be used reliably cross-browser.\n     * @param {String} str String to split.\n     * @param {RegExp|String} separator Regex or string to use for separating\n     *     the string.\n     * @param {Number} [limit] Maximum number of items to include in the result\n     *     array.\n     * @returns {Array} Array of substrings.\n     * @example\n     *\n     * // Basic use\n     * regex_split('a b c d', ' ');\n     * // -> ['a', 'b', 'c', 'd']\n     *\n     * // With limit\n     * regex_split('a b c d', ' ', 2);\n     * // -> ['a', 'b']\n     *\n     * // Backreferences in result array\n     * regex_split('..word1 word2..', /([a-z]+)(\\d+)/i);\n     * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n     */\n    var regex_split = function (str, separator, limit) {\n        // If `separator` is not a regex, use `split`\n        if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n            return split.call(str, separator, limit);\n        }\n        var output = [],\n            flags = (separator.ignoreCase ? \"i\" : \"\") +\n                    (separator.multiline  ? \"m\" : \"\") +\n                    (separator.extended   ? \"x\" : \"\") + // Proposed for ES6\n                    (separator.sticky     ? \"y\" : \"\"), // Firefox 3+\n            lastLastIndex = 0,\n            // Make `global` and avoid `lastIndex` issues by working with a copy\n            separator = new RegExp(separator.source, flags + \"g\"),\n            separator2, match, lastIndex, lastLength;\n        str += \"\"; // Type-convert\n\n        var compliantExecNpcg = typeof(/()??/.exec(\"\")[1]) === \"undefined\";\n        if (!compliantExecNpcg) {\n            // Doesn't need flags gy, but they don't hurt\n            separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n        }\n        /* Values for `limit`, per the spec:\n         * If undefined: 4294967295 // Math.pow(2, 32) - 1\n         * If 0, Infinity, or NaN: 0\n         * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n         * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n         * If other: Type-convert, then use the above rules\n         */\n        limit = typeof(limit) === \"undefined\" ?\n            -1 >>> 0 : // Math.pow(2, 32) - 1\n            limit >>> 0; // ToUint32(limit)\n        while (match = separator.exec(str)) {\n            // `separator.lastIndex` is not reliable cross-browser\n            lastIndex = match.index + match[0].length;\n            if (lastIndex > lastLastIndex) {\n                output.push(str.slice(lastLastIndex, match.index));\n                // Fix browsers whose `exec` methods don't consistently return `undefined` for\n                // nonparticipating capturing groups\n                if (!compliantExecNpcg && match.length > 1) {\n                    match[0].replace(separator2, function () {\n                        for (var i = 1; i < arguments.length - 2; i++) {\n                            if (typeof(arguments[i]) === \"undefined\") {\n                                match[i] = undefined;\n                            }\n                        }\n                    });\n                }\n                if (match.length > 1 && match.index < str.length) {\n                    Array.prototype.push.apply(output, match.slice(1));\n                }\n                lastLength = match[0].length;\n                lastLastIndex = lastIndex;\n                if (output.length >= limit) {\n                    break;\n                }\n            }\n            if (separator.lastIndex === match.index) {\n                separator.lastIndex++; // Avoid an infinite loop\n            }\n        }\n        if (lastLastIndex === str.length) {\n            if (lastLength || !separator.test(\"\")) {\n                output.push(\"\");\n            }\n        } else {\n            output.push(str.slice(lastLastIndex));\n        }\n        return output.length > limit ? output.slice(0, limit) : output;\n    };\n\n    //============================================================================\n    // End contributed Cross-browser RegEx Split\n    //============================================================================\n\n\n    var uuid = function () {\n        // http://www.ietf.org/rfc/rfc4122.txt\n        var s = [];\n        var hexDigits = \"0123456789ABCDEF\";\n        for (var i = 0; i < 32; i++) {\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n        }\n        s[12] = \"4\";  // bits 12-15 of the time_hi_and_version field to 0010\n        s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\n        var uuid = s.join(\"\");\n        return uuid;\n    };\n\n\n    //Fix raw text to parse correctly in crazy XML\n    function xmlencode(string) {\n        return string.replace(/\\&/g,'&'+'amp;')\n            .replace(/</g,'&'+'lt;')\n            .replace(/>/g,'&'+'gt;')\n            .replace(/\\'/g,'&'+'apos;')\n            .replace(/\\\"/g,'&'+'quot;')\n            .replace(/`/g,'&'+'#96;');\n    }\n\n\n    //Map from terminal commands to CSS classes\n    var ansi_colormap = {\n        \"01\":\"ansibold\",\n        \n        \"30\":\"ansiblack\",\n        \"31\":\"ansired\",\n        \"32\":\"ansigreen\",\n        \"33\":\"ansiyellow\",\n        \"34\":\"ansiblue\",\n        \"35\":\"ansipurple\",\n        \"36\":\"ansicyan\",\n        \"37\":\"ansigray\",\n        \n        \"40\":\"ansibgblack\",\n        \"41\":\"ansibgred\",\n        \"42\":\"ansibggreen\",\n        \"43\":\"ansibgyellow\",\n        \"44\":\"ansibgblue\",\n        \"45\":\"ansibgpurple\",\n        \"46\":\"ansibgcyan\",\n        \"47\":\"ansibggray\"\n    };\n    \n    function _process_numbers(attrs, numbers) {\n        // process ansi escapes\n        var n = numbers.shift();\n        if (ansi_colormap[n]) {\n            if ( ! attrs[\"class\"] ) {\n                attrs[\"class\"] = ansi_colormap[n];\n            } else {\n                attrs[\"class\"] += \" \" + ansi_colormap[n];\n            }\n        } else if (n == \"38\" || n == \"48\") {\n            // VT100 256 color or 24 bit RGB\n            if (numbers.length < 2) {\n                console.log(\"Not enough fields for VT100 color\", numbers);\n                return;\n            }\n            \n            var index_or_rgb = numbers.shift();\n            var r,g,b;\n            if (index_or_rgb == \"5\") {\n                // 256 color\n                var idx = parseInt(numbers.shift());\n                if (idx < 16) {\n                    // indexed ANSI\n                    // ignore bright / non-bright distinction\n                    idx = idx % 8;\n                    var ansiclass = ansi_colormap[n[0] + (idx % 8).toString()];\n                    if ( ! attrs[\"class\"] ) {\n                        attrs[\"class\"] = ansiclass;\n                    } else {\n                        attrs[\"class\"] += \" \" + ansiclass;\n                    }\n                    return;\n                } else if (idx < 232) {\n                    // 216 color 6x6x6 RGB\n                    idx = idx - 16;\n                    b = idx % 6;\n                    g = Math.floor(idx / 6) % 6;\n                    r = Math.floor(idx / 36) % 6;\n                    // convert to rgb\n                    r = (r * 51);\n                    g = (g * 51);\n                    b = (b * 51);\n                } else {\n                    // grayscale\n                    idx = idx - 231;\n                    // it's 1-24 and should *not* include black or white,\n                    // so a 26 point scale\n                    r = g = b = Math.floor(idx * 256 / 26);\n                }\n            } else if (index_or_rgb == \"2\") {\n                // Simple 24 bit RGB\n                if (numbers.length > 3) {\n                    console.log(\"Not enough fields for RGB\", numbers);\n                    return;\n                }\n                r = numbers.shift();\n                g = numbers.shift();\n                b = numbers.shift();\n            } else {\n                console.log(\"unrecognized control\", numbers);\n                return;\n            }\n            if (r !== undefined) {\n                // apply the rgb color\n                var line;\n                if (n == \"38\") {\n                    line = \"color: \";\n                } else {\n                    line = \"background-color: \";\n                }\n                line = line + \"rgb(\" + r + \",\" + g + \",\" + b + \");\"\n                if ( !attrs[\"style\"] ) {\n                    attrs[\"style\"] = line;\n                } else {\n                    attrs[\"style\"] += \" \" + line;\n                }\n            }\n        }\n    }\n\n    function ansispan(str) {\n        // ansispan function adapted from github.com/mmalecki/ansispan (MIT License)\n        // regular ansi escapes (using the table above)\n        return str.replace(/\\033\\[(0?[01]|22|39)?([;\\d]+)?m/g, function(match, prefix, pattern) {\n            if (!pattern) {\n                // [(01|22|39|)m close spans\n                return \"</span>\";\n            }\n            // consume sequence of color escapes\n            var numbers = pattern.match(/\\d+/g);\n            var attrs = {};\n            while (numbers.length > 0) {\n                _process_numbers(attrs, numbers);\n            }\n            \n            var span = \"<span \";\n            for (var attr in attrs) {\n                var value = attrs[attr];\n                span = span + \" \" + attr + '=\"' + attrs[attr] + '\"';\n            }\n            return span + \">\";\n        });\n    };\n    \n    // Transform ANSI color escape codes into HTML <span> tags with css\n    // classes listed in the above ansi_colormap object. The actual color used\n    // are set in the css file.\n    function fixConsole(txt) {\n        txt = xmlencode(txt);\n        var re = /\\033\\[([\\dA-Fa-f;]*?)m/;\n        var opened = false;\n        var cmds = [];\n        var opener = \"\";\n        var closer = \"\";\n\n        // Strip all ANSI codes that are not color related.  Matches\n        // all ANSI codes that do not end with \"m\".\n        var ignored_re = /(?=(\\033\\[[\\d;=]*[a-ln-zA-Z]{1}))\\1(?!m)/g;\n        txt = txt.replace(ignored_re, \"\");\n        \n        // color ansi codes\n        txt = ansispan(txt);\n        return txt;\n    }\n\n    // Remove chunks that should be overridden by the effect of\n    // carriage return characters\n    function fixCarriageReturn(txt) {\n        var tmp = txt;\n        do {\n            txt = tmp;\n            tmp = txt.replace(/\\r+\\n/gm, '\\n'); // \\r followed by \\n --> newline\n            tmp = tmp.replace(/^.*\\r+/gm, '');  // Other \\r --> clear line\n        } while (tmp.length < txt.length);\n        return txt;\n    }\n\n    // Locate any URLs and convert them to a anchor tag\n    function autoLinkUrls(txt) {\n        return txt.replace(/(^|\\s)(https?|ftp)(:[^'\">\\s]+)/gi,\n            \"$1<a target=\\\"_blank\\\" href=\\\"$2$3\\\">$2$3</a>\");\n    }\n\n    var points_to_pixels = function (points) {\n        // A reasonably good way of converting between points and pixels.\n        var test = $('<div style=\"display: none; width: 10000pt; padding:0; border:0;\"></div>');\n        $(body).append(test);\n        var pixel_per_point = test.width()/10000;\n        test.remove();\n        return Math.floor(points*pixel_per_point);\n    };\n    \n    var always_new = function (constructor) {\n        // wrapper around contructor to avoid requiring `var a = new constructor()`\n        // useful for passing constructors as callbacks,\n        // not for programmer laziness.\n        // from http://programmers.stackexchange.com/questions/118798\n        return function () {\n            var obj = Object.create(constructor.prototype);\n            constructor.apply(obj, arguments);\n            return obj;\n        };\n    };\n\n    var url_path_join = function () {\n        // join a sequence of url components with '/'\n        var url = '';\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[i] === '') {\n                continue;\n            }\n            if (url.length > 0 && url[url.length-1] != '/') {\n                url = url + '/' + arguments[i];\n            } else {\n                url = url + arguments[i];\n            }\n        }\n        url = url.replace(/\\/\\/+/, '/');\n        return url;\n    };\n    \n    var parse_url = function (url) {\n        // an `a` element with an href allows attr-access to the parsed segments of a URL\n        // a = parse_url(\"http://localhost:8888/path/name#hash\")\n        // a.protocol = \"http:\"\n        // a.host     = \"localhost:8888\"\n        // a.hostname = \"localhost\"\n        // a.port     = 8888\n        // a.pathname = \"/path/name\"\n        // a.hash     = \"#hash\"\n        var a = document.createElement(\"a\");\n        a.href = url;\n        return a;\n    };\n    \n    var encode_uri_components = function (uri) {\n        // encode just the components of a multi-segment uri,\n        // leaving '/' separators\n        return uri.split('/').map(encodeURIComponent).join('/');\n    };\n    \n    var url_join_encode = function () {\n        // join a sequence of url components with '/',\n        // encoding each component with encodeURIComponent\n        return encode_uri_components(url_path_join.apply(null, arguments));\n    };\n\n\n    var splitext = function (filename) {\n        // mimic Python os.path.splitext\n        // Returns ['base', '.ext']\n        var idx = filename.lastIndexOf('.');\n        if (idx > 0) {\n            return [filename.slice(0, idx), filename.slice(idx)];\n        } else {\n            return [filename, ''];\n        }\n    };\n\n\n    var escape_html = function (text) {\n        // escape text to HTML\n        return $(\"<div/>\").text(text).html();\n    }\n\n\n    var get_body_data = function(key) {\n        // get a url-encoded item from body.data and decode it\n        // we should never have any encoded URLs anywhere else in code\n        // until we are building an actual request\n        return decodeURIComponent($('body').data(key));\n    };\n\n\n    // http://stackoverflow.com/questions/2400935/browser-detection-in-javascript\n    var browser = (function() {\n        if (typeof navigator === 'undefined') {\n            // navigator undefined in node\n            return 'None';\n        }\n        var N= navigator.appName, ua= navigator.userAgent, tem;\n        var M= ua.match(/(opera|chrome|safari|firefox|msie)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n        if (M && (tem= ua.match(/version\\/([\\.\\d]+)/i))!= null) M[2]= tem[1];\n        M= M? [M[1], M[2]]: [N, navigator.appVersion,'-?'];\n        return M;\n    })();\n\n    // http://stackoverflow.com/questions/11219582/how-to-detect-my-browser-version-and-operating-system-using-javascript\n    var platform = (function () {\n        if (typeof navigator === 'undefined') {\n            // navigator undefined in node\n            return 'None';\n        }\n        var OSName=\"None\";\n        if (navigator.appVersion.indexOf(\"Win\")!=-1) OSName=\"Windows\";\n        if (navigator.appVersion.indexOf(\"Mac\")!=-1) OSName=\"MacOS\";\n        if (navigator.appVersion.indexOf(\"X11\")!=-1) OSName=\"UNIX\";\n        if (navigator.appVersion.indexOf(\"Linux\")!=-1) OSName=\"Linux\";\n        return OSName\n    })();\n\n    var is_or_has = function (a, b) {\n        // Is b a child of a or a itself?\n        return a.has(b).length !==0 || a.is(b);\n    }\n\n    var is_focused = function (e) {\n        // Is element e, or one of its children focused?\n        e = $(e);\n        var target = $(document.activeElement);\n        if (target.length > 0) {\n            if (is_or_has(e, target)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n\n    return {\n        regex_split : regex_split,\n        uuid : uuid,\n        fixConsole : fixConsole,\n        fixCarriageReturn : fixCarriageReturn,\n        autoLinkUrls : autoLinkUrls,\n        points_to_pixels : points_to_pixels,\n        get_body_data : get_body_data,\n        parse_url : parse_url,\n        url_path_join : url_path_join,\n        url_join_encode : url_join_encode,\n        encode_uri_components : encode_uri_components,\n        splitext : splitext,\n        escape_html : escape_html,\n        always_new : always_new,\n        browser : browser,\n        platform: platform,\n        is_or_has : is_or_has,\n        is_focused : is_focused\n    };\n\n}(IPython));\n\n//----------------------------------------------------------------------------\n//  Copyright (C) 2008-2011  The IPython Development Team\n//\n//  Distributed under the terms of the BSD License.  The full license is in\n//  the file COPYING, distributed as part of this software.\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Events\n//============================================================================\n\n// Give us an object to bind all events to. This object should be created\n// before all other objects so it exists when others register event handlers.\n// To trigger an event handler:\n// $([IPython.events]).trigger('event.Namespace');\n// To handle it:\n// $([IPython.events]).on('event.Namespace',function () {});\n\nvar IPython = (function (IPython) {\n    \"use strict\";\n\n    var utils = IPython.utils;\n\n    var Events = function () {};\n\n    IPython.Events = Events;\n    IPython.events = new Events();\n\n    return IPython;\n\n}(IPython));\n\n//----------------------------------------------------------------------------\n//  Copyright (C) 2013  The IPython Development Team\n//\n//  Distributed under the terms of the BSD License.  The full license is in\n//  the file COPYING, distributed as part of this software.\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Comm and CommManager bases\n//============================================================================\n/**\n * Base Comm classes\n * @module IPython\n * @namespace IPython\n * @submodule comm\n */\n\nvar IPython = (function (IPython) {\n    \"use strict\";\n\n    //-----------------------------------------------------------------------\n    // CommManager class\n    //-----------------------------------------------------------------------\n    \n    var CommManager = function (kernel) {\n        this.comms = {};\n        this.targets = {};\n        if (kernel !== undefined) {\n            this.init_kernel(kernel);\n        }\n    };\n    \n    CommManager.prototype.init_kernel = function (kernel) {\n        // connect the kernel, and register message handlers\n        this.kernel = kernel;\n        var msg_types = ['comm_open', 'comm_msg', 'comm_close'];\n        for (var i = 0; i < msg_types.length; i++) {\n            var msg_type = msg_types[i];\n            kernel.register_iopub_handler(msg_type, $.proxy(this[msg_type], this));\n        }\n    };\n    \n    CommManager.prototype.new_comm = function (target_name, data, callbacks, metadata) {\n        // Create a new Comm, register it, and open its Kernel-side counterpart\n        // Mimics the auto-registration in `Comm.__init__` in the IPython Comm\n        var comm = new Comm(target_name);\n        this.register_comm(comm);\n        comm.open(data, callbacks, metadata);\n        return comm;\n    };\n    \n    CommManager.prototype.register_target = function (target_name, f) {\n        // Register a target function for a given target name\n        this.targets[target_name] = f;\n    };\n    \n    CommManager.prototype.unregister_target = function (target_name, f) {\n        // Unregister a target function for a given target name\n        delete this.targets[target_name];\n    };\n    \n    CommManager.prototype.register_comm = function (comm) {\n        // Register a comm in the mapping\n        this.comms[comm.comm_id] = comm;\n        comm.kernel = this.kernel;\n        return comm.comm_id;\n    };\n    \n    CommManager.prototype.unregister_comm = function (comm_id) {\n        // Remove a comm from the mapping\n        delete this.comms[comm_id];\n    };\n    \n    // comm message handlers\n    \n    CommManager.prototype.comm_open = function (msg) {\n        var content = msg.content;\n        var f = this.targets[content.target_name];\n        if (f === undefined) {\n            console.log(\"No such target registered: \", content.target_name);\n            console.log(\"Available targets are: \", this.targets);\n            return;\n        }\n        var comm = new Comm(content.target_name, content.comm_id);\n        this.register_comm(comm);\n        try {\n            f(comm, msg);\n        } catch (e) {\n            console.log(\"Exception opening new comm:\", e, e.stack, msg);\n            comm.close();\n            this.unregister_comm(comm);\n        }\n    };\n    \n    CommManager.prototype.comm_close = function (msg) {\n        var content = msg.content;\n        var comm = this.comms[content.comm_id];\n        if (comm === undefined) {\n            return;\n        }\n        delete this.comms[content.comm_id];\n        try {\n            comm.handle_close(msg);\n        } catch (e) {\n            console.log(\"Exception closing comm: \", e, e.stack, msg);\n        }\n    };\n    \n    CommManager.prototype.comm_msg = function (msg) {\n        var content = msg.content;\n        var comm = this.comms[content.comm_id];\n        if (comm === undefined) {\n            return;\n        }\n        try {\n            comm.handle_msg(msg);\n        } catch (e) {\n            console.log(\"Exception handling comm msg: \", e, e.stack, msg);\n        }\n    };\n    \n    //-----------------------------------------------------------------------\n    // Comm base class\n    //-----------------------------------------------------------------------\n    \n    var Comm = function (target_name, comm_id) {\n        this.target_name = target_name;\n        this.comm_id = comm_id || IPython.utils.uuid();\n        this._msg_callback = this._close_callback = null;\n    };\n    \n    // methods for sending messages\n    Comm.prototype.open = function (data, callbacks, metadata) {\n        var content = {\n            comm_id : this.comm_id,\n            target_name : this.target_name,\n            data : data || {},\n        };\n        return this.kernel.send_shell_message(\"comm_open\", content, callbacks, metadata);\n    };\n    \n    Comm.prototype.send = function (data, callbacks, metadata) {\n        var content = {\n            comm_id : this.comm_id,\n            data : data || {},\n        };\n        return this.kernel.send_shell_message(\"comm_msg\", content, callbacks, metadata);\n    };\n    \n    Comm.prototype.close = function (data, callbacks, metadata) {\n        var content = {\n            comm_id : this.comm_id,\n            data : data || {},\n        };\n        return this.kernel.send_shell_message(\"comm_close\", content, callbacks, metadata);\n    };\n    \n    // methods for registering callbacks for incoming messages\n    Comm.prototype._register_callback = function (key, callback) {\n        this['_' + key + '_callback'] = callback;\n    };\n    \n    Comm.prototype.on_msg = function (callback) {\n        this._register_callback('msg', callback);\n    };\n    \n    Comm.prototype.on_close = function (callback) {\n        this._register_callback('close', callback);\n    };\n    \n    // methods for handling incoming messages\n    \n    Comm.prototype._maybe_callback = function (key, msg) {\n        var callback = this['_' + key + '_callback'];\n        if (callback) {\n            try {\n                callback(msg);\n            } catch (e) {\n                console.log(\"Exception in Comm callback\", e, e.stack, msg);\n            }\n        }\n    };\n    \n    Comm.prototype.handle_msg = function (msg) {\n        this._maybe_callback('msg', msg);\n    };\n    \n    Comm.prototype.handle_close = function (msg) {\n        this._maybe_callback('close', msg);\n    };\n    \n    IPython.CommManager = CommManager;\n    IPython.Comm = Comm;\n    \n    return IPython;\n\n}(IPython));\n\n//----------------------------------------------------------------------------\n//  Copyright (C) 2008-2011  The IPython Development Team\n//\n//  Distributed under the terms of the BSD License.  The full license is in\n//  the file COPYING, distributed as part of this software.\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Kernel\n//============================================================================\n\n/**\n * @module IPython\n * @namespace IPython\n * @submodule Kernel\n */\n\nvar IPython = (function (IPython) {\n    \"use strict\";\n    \n    var utils = IPython.utils;\n\n    // Initialization and connection.\n    /**\n     * A Kernel Class to communicate with the Python kernel\n     * @Class Kernel\n     */\n    var Kernel = function (kernel_service_url) {\n        this.kernel_id = null;\n        this.shell_channel = null;\n        this.iopub_channel = null;\n        this.stdin_channel = null;\n        this.kernel_service_url = kernel_service_url;\n        this.running = false;\n        this.username = \"username\";\n        this.session_id = utils.uuid();\n        this._msg_callbacks = {};\n\n        if (typeof(WebSocket) !== 'undefined') {\n            this.WebSocket = WebSocket;\n        } else if (typeof(MozWebSocket) !== 'undefined') {\n            this.WebSocket = MozWebSocket;\n        } else {\n            alert('Your browser does not have WebSocket support, please try Chrome, Safari or Firefox â‰¥ 6. Firefox 4 and 5 are also supported by you have to enable WebSockets in about:config.');\n        }\n        \n        this.bind_events();\n        this.init_iopub_handlers();\n        this.comm_manager = new IPython.CommManager(this);\n        this.widget_manager = new IPython.WidgetManager(this.comm_manager);\n    };\n\n\n    Kernel.prototype._get_msg = function (msg_type, content, metadata) {\n        var msg = {\n            header : {\n                msg_id : utils.uuid(),\n                username : this.username,\n                session : this.session_id,\n                msg_type : msg_type\n            },\n            metadata : metadata || {},\n            content : content,\n            parent_header : {}\n        };\n        return msg;\n    };\n    \n    Kernel.prototype.bind_events = function () {\n        var that = this;\n        $([IPython.events]).on('send_input_reply.Kernel', function(evt, data) { \n            that.send_input_reply(data);\n        });\n    };\n    \n    // Initialize the iopub handlers\n    \n    Kernel.prototype.init_iopub_handlers = function () {\n        var output_types = ['stream', 'display_data', 'pyout', 'pyerr'];\n        this._iopub_handlers = {};\n        this.register_iopub_handler('status', $.proxy(this._handle_status_message, this));\n        this.register_iopub_handler('clear_output', $.proxy(this._handle_clear_output, this));\n        \n        for (var i=0; i < output_types.length; i++) {\n            this.register_iopub_handler(output_types[i], $.proxy(this._handle_output_message, this));\n        }\n    };\n\n    /**\n     * Start the Python kernel\n     * @method start\n     */\n    Kernel.prototype.start = function (params) {\n        params = params || {};\n        if (!this.running) {\n            var qs = $.param(params);\n            $.post(utils.url_join_encode(this.kernel_service_url) + '?' + qs,\n                $.proxy(this._kernel_started, this),\n                'json'\n            );\n        }\n    };\n\n    /**\n     * Restart the python kernel.\n     *\n     * Emit a 'status_restarting.Kernel' event with\n     * the current object as parameter\n     *\n     * @method restart\n     */\n    Kernel.prototype.restart = function () {\n        $([IPython.events]).trigger('status_restarting.Kernel', {kernel: this});\n        if (this.running) {\n            this.stop_channels();\n            $.post(utils.url_join_encode(this.kernel_url, \"restart\"),\n                $.proxy(this._kernel_started, this),\n                'json'\n            );\n        }\n    };\n\n\n    Kernel.prototype._kernel_started = function (json) {\n        console.log(\"Kernel started: \", json.id);\n        this.running = true;\n        this.kernel_id = json.id;\n        // trailing 's' in https will become wss for secure web sockets\n        this.ws_host = location.protocol.replace('http', 'ws') + \"//\" + location.host;\n        this.kernel_url = utils.url_path_join(this.kernel_service_url, this.kernel_id);\n        this.start_channels();\n    };\n\n\n    Kernel.prototype._websocket_closed = function(ws_url, early) {\n        this.stop_channels();\n        $([IPython.events]).trigger('websocket_closed.Kernel',\n            {ws_url: ws_url, kernel: this, early: early}\n        );\n    };\n\n    /**\n     * Start the `shell`and `iopub` channels.\n     * Will stop and restart them if they already exist.\n     *\n     * @method start_channels\n     */\n    Kernel.prototype.start_channels = function () {\n        var that = this;\n        this.stop_channels();\n        var ws_host_url = this.ws_host + this.kernel_url;\n        console.log(\"Starting WebSockets:\", ws_host_url);\n        this.shell_channel = new this.WebSocket(\n            this.ws_host + utils.url_join_encode(this.kernel_url, \"shell\")\n        );\n        this.stdin_channel = new this.WebSocket(\n            this.ws_host + utils.url_join_encode(this.kernel_url, \"stdin\")\n        );\n        this.iopub_channel = new this.WebSocket(\n            this.ws_host + utils.url_join_encode(this.kernel_url, \"iopub\")\n        );\n        \n        var already_called_onclose = false; // only alert once\n        var ws_closed_early = function(evt){\n            if (already_called_onclose){\n                return;\n            }\n            already_called_onclose = true;\n            if ( ! evt.wasClean ){\n                that._websocket_closed(ws_host_url, true);\n            }\n        };\n        var ws_closed_late = function(evt){\n            if (already_called_onclose){\n                return;\n            }\n            already_called_onclose = true;\n            if ( ! evt.wasClean ){\n                that._websocket_closed(ws_host_url, false);\n            }\n        };\n        var channels = [this.shell_channel, this.iopub_channel, this.stdin_channel];\n        for (var i=0; i < channels.length; i++) {\n            channels[i].onopen = $.proxy(this._ws_opened, this);\n            channels[i].onclose = ws_closed_early;\n        }\n        // switch from early-close to late-close message after 1s\n        setTimeout(function() {\n            for (var i=0; i < channels.length; i++) {\n                if (channels[i] !== null) {\n                    channels[i].onclose = ws_closed_late;\n                }\n            }\n        }, 1000);\n        this.shell_channel.onmessage = $.proxy(this._handle_shell_reply, this);\n        this.iopub_channel.onmessage = $.proxy(this._handle_iopub_message, this);\n        this.stdin_channel.onmessage = $.proxy(this._handle_input_request, this);\n    };\n\n    /**\n     * Handle a websocket entering the open state\n     * sends session and cookie authentication info as first message.\n     * Once all sockets are open, signal the Kernel.status_started event.\n     * @method _ws_opened\n     */\n    Kernel.prototype._ws_opened = function (evt) {\n        // send the session id so the Session object Python-side\n        // has the same identity\n        evt.target.send(this.session_id + ':' + document.cookie);\n        \n        var channels = [this.shell_channel, this.iopub_channel, this.stdin_channel];\n        for (var i=0; i < channels.length; i++) {\n            // if any channel is not ready, don't trigger event.\n            if ( !channels[i].readyState ) return;\n        }\n        // all events ready, trigger started event.\n        $([IPython.events]).trigger('status_started.Kernel', {kernel: this});\n    };\n    \n    /**\n     * Stop the websocket channels.\n     * @method stop_channels\n     */\n    Kernel.prototype.stop_channels = function () {\n        var channels = [this.shell_channel, this.iopub_channel, this.stdin_channel];\n        for (var i=0; i < channels.length; i++) {\n            if ( channels[i] !== null ) {\n                channels[i].onclose = null;\n                channels[i].close();\n            }\n        }\n        this.shell_channel = this.iopub_channel = this.stdin_channel = null;\n    };\n\n    // Main public methods.\n    \n    // send a message on the Kernel's shell channel\n    Kernel.prototype.send_shell_message = function (msg_type, content, callbacks, metadata) {\n        var msg = this._get_msg(msg_type, content, metadata);\n        this.shell_channel.send(JSON.stringify(msg));\n        this.set_callbacks_for_msg(msg.header.msg_id, callbacks);\n        return msg.header.msg_id;\n    };\n\n    /**\n     * Get kernel info\n     *\n     * @param callback {function}\n     * @method object_info\n     *\n     * When calling this method, pass a callback function that expects one argument.\n     * The callback will be passed the complete `kernel_info_reply` message documented\n     * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-info)\n     */\n    Kernel.prototype.kernel_info = function (callback) {\n        var callbacks;\n        if (callback) {\n            callbacks = { shell : { reply : callback } };\n        }\n        return this.send_shell_message(\"kernel_info_request\", {}, callbacks);\n    };\n\n    /**\n     * Get info on an object\n     *\n     * @param objname {string}\n     * @param callback {function}\n     * @method object_info\n     *\n     * When calling this method, pass a callback function that expects one argument.\n     * The callback will be passed the complete `object_info_reply` message documented\n     * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#object-information)\n     */\n    Kernel.prototype.object_info = function (objname, callback) {\n        var callbacks;\n        if (callback) {\n            callbacks = { shell : { reply : callback } };\n        }\n        \n        if (typeof(objname) !== null && objname !== null) {\n            var content = {\n                oname : objname.toString(),\n                detail_level : 0,\n            };\n            return this.send_shell_message(\"object_info_request\", content, callbacks);\n        }\n        return;\n    };\n\n    /**\n     * Execute given code into kernel, and pass result to callback.\n     *\n     * @async\n     * @method execute\n     * @param {string} code\n     * @param [callbacks] {Object} With the following keys (all optional)\n     *      @param callbacks.shell.reply {function}\n     *      @param callbacks.shell.payload.[payload_name] {function}\n     *      @param callbacks.iopub.output {function}\n     *      @param callbacks.iopub.clear_output {function}\n     *      @param callbacks.input {function}\n     * @param {object} [options]\n     *      @param [options.silent=false] {Boolean}\n     *      @param [options.user_expressions=empty_dict] {Dict}\n     *      @param [options.user_variables=empty_list] {List od Strings}\n     *      @param [options.allow_stdin=false] {Boolean} true|false\n     *\n     * @example\n     *\n     * The options object should contain the options for the execute call. Its default\n     * values are:\n     *\n     *      options = {\n     *        silent : true,\n     *        user_variables : [],\n     *        user_expressions : {},\n     *        allow_stdin : false\n     *      }\n     *\n     * When calling this method pass a callbacks structure of the form:\n     *\n     *      callbacks = {\n     *       shell : {\n     *         reply : execute_reply_callback,\n     *         payload : {\n     *           set_next_input : set_next_input_callback,\n     *         }\n     *       },\n     *       iopub : {\n     *         output : output_callback,\n     *         clear_output : clear_output_callback,\n     *       },\n     *       input : raw_input_callback\n     *      }\n     *\n     * Each callback will be passed the entire message as a single arugment.\n     * Payload handlers will be passed the corresponding payload and the execute_reply message.\n     */\n    Kernel.prototype.execute = function (code, callbacks, options) {\n\n        var content = {\n            code : code,\n            silent : true,\n            store_history : false,\n            user_variables : [],\n            user_expressions : {},\n            allow_stdin : false\n        };\n        callbacks = callbacks || {};\n        if (callbacks.input !== undefined) {\n            content.allow_stdin = true;\n        }\n        $.extend(true, content, options);\n        $([IPython.events]).trigger('execution_request.Kernel', {kernel: this, content:content});\n        return this.send_shell_message(\"execute_request\", content, callbacks);\n    };\n\n    /**\n     * When calling this method, pass a function to be called with the `complete_reply` message\n     * as its only argument when it arrives.\n     *\n     * `complete_reply` is documented\n     * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#complete)\n     *\n     * @method complete\n     * @param line {integer}\n     * @param cursor_pos {integer}\n     * @param callback {function}\n     *\n     */\n    Kernel.prototype.complete = function (line, cursor_pos, callback) {\n        var callbacks;\n        if (callback) {\n            callbacks = { shell : { reply : callback } };\n        }\n        var content = {\n            text : '',\n            line : line,\n            block : null,\n            cursor_pos : cursor_pos\n        };\n        return this.send_shell_message(\"complete_request\", content, callbacks);\n    };\n\n\n    Kernel.prototype.interrupt = function () {\n        if (this.running) {\n            $([IPython.events]).trigger('status_interrupting.Kernel', {kernel: this});\n            $.post(utils.url_join_encode(this.kernel_url, \"interrupt\"));\n        }\n    };\n\n\n    Kernel.prototype.kill = function () {\n        if (this.running) {\n            this.running = false;\n            var settings = {\n                cache : false,\n                type : \"DELETE\"\n            };\n            $.ajax(utils.url_join_encode(this.kernel_url), settings);\n        }\n    };\n\n    Kernel.prototype.send_input_reply = function (input) {\n        var content = {\n            value : input,\n        };\n        $([IPython.events]).trigger('input_reply.Kernel', {kernel: this, content:content});\n        var msg = this._get_msg(\"input_reply\", content);\n        this.stdin_channel.send(JSON.stringify(msg));\n        return msg.header.msg_id;\n    };\n\n\n    // Reply handlers\n\n    Kernel.prototype.register_iopub_handler = function (msg_type, callback) {\n        this._iopub_handlers[msg_type] = callback;\n    };\n\n    Kernel.prototype.get_iopub_handler = function (msg_type) {\n        // get iopub handler for a specific message type\n        return this._iopub_handlers[msg_type];\n    };\n\n\n    Kernel.prototype.get_callbacks_for_msg = function (msg_id) {\n        // get callbacks for a specific message\n        return this._msg_callbacks[msg_id];\n    };\n\n\n    Kernel.prototype.clear_callbacks_for_msg = function (msg_id) {\n        if (this._msg_callbacks[msg_id] !== undefined ) {\n            delete this._msg_callbacks[msg_id];\n        }\n    };\n    \n    /* Set callbacks for a particular message.\n     * Callbacks should be a struct of the following form:\n     * shell : {\n     * \n     * }\n    \n     */\n    Kernel.prototype.set_callbacks_for_msg = function (msg_id, callbacks) {\n        if (callbacks) {\n            // shallow-copy mapping, because we will modify it at the top level\n            var cbcopy = this._msg_callbacks[msg_id] = {};\n            cbcopy.shell = callbacks.shell;\n            cbcopy.iopub = callbacks.iopub;\n            cbcopy.input = callbacks.input;\n            this._msg_callbacks[msg_id] = cbcopy;\n        }\n    };\n\n\n    Kernel.prototype._handle_shell_reply = function (e) {\n        var reply = $.parseJSON(e.data);\n        $([IPython.events]).trigger('shell_reply.Kernel', {kernel: this, reply:reply});\n        var content = reply.content;\n        var metadata = reply.metadata;\n        var parent_id = reply.parent_header.msg_id;\n        var callbacks = this.get_callbacks_for_msg(parent_id);\n        if (!callbacks || !callbacks.shell) {\n            return;\n        }\n        var shell_callbacks = callbacks.shell;\n        \n        // clear callbacks on shell\n        delete callbacks.shell;\n        delete callbacks.input;\n        if (!callbacks.iopub) {\n            this.clear_callbacks_for_msg(parent_id);\n        }\n        \n        if (shell_callbacks.reply !== undefined) {\n            shell_callbacks.reply(reply);\n        }\n        if (content.payload && shell_callbacks.payload) {\n            this._handle_payloads(content.payload, shell_callbacks.payload, reply);\n        }\n    };\n\n\n    Kernel.prototype._handle_payloads = function (payloads, payload_callbacks, msg) {\n        var l = payloads.length;\n        // Payloads are handled by triggering events because we don't want the Kernel\n        // to depend on the Notebook or Pager classes.\n        for (var i=0; i<l; i++) {\n            var payload = payloads[i];\n            var callback = payload_callbacks[payload.source];\n            if (callback) {\n                callback(payload, msg);\n            }\n        }\n    };\n\n    Kernel.prototype._handle_status_message = function (msg) {\n        var execution_state = msg.content.execution_state;\n        var parent_id = msg.parent_header.msg_id;\n        \n        // dispatch status msg callbacks, if any\n        var callbacks = this.get_callbacks_for_msg(parent_id);\n        if (callbacks && callbacks.iopub && callbacks.iopub.status) {\n            try {\n                callbacks.iopub.status(msg);\n            } catch (e) {\n                console.log(\"Exception in status msg handler\", e, e.stack);\n            }\n        }\n        \n        if (execution_state === 'busy') {\n            $([IPython.events]).trigger('status_busy.Kernel', {kernel: this});\n        } else if (execution_state === 'idle') {\n            // clear callbacks on idle, there can be no more\n            if (callbacks !== undefined) {\n                delete callbacks.iopub;\n                delete callbacks.input;\n                if (!callbacks.shell) {\n                    this.clear_callbacks_for_msg(parent_id);\n                }\n            }\n            // trigger status_idle event\n            $([IPython.events]).trigger('status_idle.Kernel', {kernel: this});\n        } else if (execution_state === 'restarting') {\n            // autorestarting is distinct from restarting,\n            // in that it means the kernel died and the server is restarting it.\n            // status_restarting sets the notification widget,\n            // autorestart shows the more prominent dialog.\n            $([IPython.events]).trigger('status_autorestarting.Kernel', {kernel: this});\n            $([IPython.events]).trigger('status_restarting.Kernel', {kernel: this});\n        } else if (execution_state === 'dead') {\n            this.stop_channels();\n            $([IPython.events]).trigger('status_dead.Kernel', {kernel: this});\n        }\n    };\n    \n    \n    // handle clear_output message\n    Kernel.prototype._handle_clear_output = function (msg) {\n        var callbacks = this.get_callbacks_for_msg(msg.parent_header.msg_id);\n        if (!callbacks || !callbacks.iopub) {\n            return;\n        }\n        var callback = callbacks.iopub.clear_output;\n        if (callback) {\n            callback(msg);\n        }\n    };\n\n\n    // handle an output message (pyout, display_data, etc.)\n    Kernel.prototype._handle_output_message = function (msg) {\n        var callbacks = this.get_callbacks_for_msg(msg.parent_header.msg_id);\n        if (!callbacks || !callbacks.iopub) {\n            return;\n        }\n        var callback = callbacks.iopub.output;\n        if (callback) {\n            callback(msg);\n        }\n    };\n\n    // dispatch IOPub messages to respective handlers.\n    // each message type should have a handler.\n    Kernel.prototype._handle_iopub_message = function (e) {\n        var msg = $.parseJSON(e.data);\n\n        var handler = this.get_iopub_handler(msg.header.msg_type);\n        if (handler !== undefined) {\n            handler(msg);\n        }\n    };\n\n\n    Kernel.prototype._handle_input_request = function (e) {\n        var request = $.parseJSON(e.data);\n        var header = request.header;\n        var content = request.content;\n        var metadata = request.metadata;\n        var msg_type = header.msg_type;\n        if (msg_type !== 'input_request') {\n            console.log(\"Invalid input request!\", request);\n            return;\n        }\n        var callbacks = this.get_callbacks_for_msg(request.parent_header.msg_id);\n        if (callbacks) {\n            if (callbacks.input) {\n                callbacks.input(request);\n            }\n        }\n    };\n\n\n    IPython.Kernel = Kernel;\n\n    return IPython;\n\n}(IPython));\n\n//----------------------------------------------------------------------------\n//  Copyright (C) 2013  The IPython Development Team\n//\n//  Distributed under the terms of the BSD License.  The full license is in\n//  the file COPYING, distributed as part of this software.\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Notebook\n//============================================================================\n\nvar IPython = (function (IPython) {\n    \"use strict\";\n    \n    var utils = IPython.utils;\n    \n    var Session = function(notebook, options){\n        this.kernel = null;\n        this.id = null;\n        this.notebook = notebook;\n        this.name = notebook.notebook_name;\n        this.path = notebook.notebook_path;\n        this.base_url = notebook.base_url;\n    };\n    \n    Session.prototype.start = function(callback) {\n        var that = this;\n        var model = {\n            notebook : {\n                name : this.name,\n                path : this.path\n            }\n        };\n        var settings = {\n            processData : false,\n            cache : false,\n            type : \"POST\",\n            data: JSON.stringify(model),\n            dataType : \"json\",\n            success : function (data, status, xhr) {\n                that._handle_start_success(data);\n                if (callback) {\n                    callback(data, status, xhr);\n                }\n            },\n        };\n        var url = utils.url_join_encode(this.base_url, 'api/sessions');\n        $.ajax(url, settings);\n    };\n    \n    Session.prototype.rename_notebook = function (name, path) {\n        this.name = name;\n        this.path = path;\n        var model = {\n            notebook : {\n                name : this.name,\n                path : this.path\n            }\n        };\n        var settings = {\n            processData : false,\n            cache : false,\n            type : \"PATCH\",\n            data: JSON.stringify(model),\n            dataType : \"json\",\n        };\n        var url = utils.url_join_encode(this.base_url, 'api/sessions', this.id);\n        $.ajax(url, settings);\n    };\n    \n    Session.prototype.delete = function() {\n        var settings = {\n            processData : false,\n            cache : false,\n            type : \"DELETE\",\n            dataType : \"json\",\n        };\n        this.kernel.running = false;\n        var url = utils.url_join_encode(this.base_url, 'api/sessions', this.id);\n        $.ajax(url, settings);\n    };\n    \n    // Kernel related things\n    /**\n     * Create the Kernel object associated with this Session.\n     * \n     * @method _handle_start_success\n     */\n    Session.prototype._handle_start_success = function (data, status, xhr) {\n        this.id = data.id;\n        var kernel_service_url = utils.url_path_join(this.base_url, \"api/kernels\");\n        this.kernel = new IPython.Kernel(kernel_service_url);\n        this.kernel._kernel_started(data.kernel);\n    };\n    \n    /**\n     * Prompt the user to restart the IPython kernel.\n     * \n     * @method restart_kernel\n     */\n    Session.prototype.restart_kernel = function () {\n        this.kernel.restart();\n    };\n    \n    Session.prototype.interrupt_kernel = function() {\n        this.kernel.interrupt();\n    };\n    \n\n    Session.prototype.kill_kernel = function() {\n        this.kernel.kill();\n    };\n    \n    IPython.Session = Session;\n\n    return IPython;\n\n}(IPython));\nIPython.WidgetManager = function(){;};\n\nIPython.Session.prototype._handle_start_success = function (data, status, xhr) {\n    this.id = data.id;\n    // since base_url can be absolute path, we just assume that the pathname will\n    // always be '/'\n    var kernel_service_url = \"/api/kernels\";\n    this.kernel = new IPython.Kernel(kernel_service_url);\n    this.kernel.base_url = this.base_url;\n    this.kernel._kernel_started(data.kernel);\n};\n\nIPython.Kernel.prototype._kernel_started = function (json) {\n    console.log(\"Kernel started: \", json.id);\n    this.running = true;\n    this.kernel_id = json.id;\n    // trailing 's' in https will become wss for secure web sockets\n    if (typeof location != 'undefined') {\n        this.ws_host = location.protocol.replace('http', 'ws') + \"//\" + location.host;\n    } else {\n        // if location is undefined, we assume base_url is aboslute\n        this.ws_host = this.base_url.replace('http', 'ws');\n    }\n    this.kernel_url = IPython.utils.url_path_join(this.kernel_service_url, this.kernel_id);\n    this.start_channels();\n};\n\n/*\n * Changed to respect absolute urls\n */\nIPython.utils.url_join_encode = function () {\n    // join a sequence of url components with '/',\n    // encoding each component with encodeURIComponent\n    //\n    var uri = IPython.utils.url_path_join.apply(null, arguments);\n    if (uri.indexOf(\"://\") == -1) { // relative path\n        return IPython.utils.encode_uri_components(uri);\n    }\n\n    var bits = uri.split(\"/\");\n    // the first three represent the protocol and host\n    var components = bits.splice(3);\n\n    var protocol_host = bits.join('/');\n    var path = components.map(encodeURIComponent).join('/');\n    var ret = protocol_host + '/' + path;\n    return ret;\n};\n\n/*\n * Will not replace '//' which would mess up absolute urls\n */\nIPython.utils.url_path_join = function () {\n    // join a sequence of url components with '/'\n    var url = '';\n    for (var i = 0; i < arguments.length; i++) {\n        if (arguments[i] === '') {\n            continue;\n        }\n        if (url.length > 0 && (url[url.length-1] != '/' && arguments[i][0] != '/')) {\n            url = url + '/' + arguments[i];\n        } else {\n            url = url + arguments[i];\n        }\n    }\n    return url;\n};\n";
// Assume that jquery is coming externally
if (typeof($) === 'undefined') {
  window.$ = require('jquery-browserify');
}
$.support.cors = true;
module.exports = new Function(content + ";IPython.$ = $;return IPython;")();
